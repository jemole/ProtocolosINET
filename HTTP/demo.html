<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>HTML</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>HTTP</h1>
					<h3>Historia y avance con el tiempo</h3>
					<p>
					<small>Hecho por Carlos Trujillo, Jose María Parrilla, José Palacios y Víctor López.</small>
					</p>
				</section>

				<section>
				<section>
					<h2>Comienzos de HTML</h2>
					<p>Protocolo basado en la web, inventado por Tim Berners-Lee entre 1989 y 1991. Este mantiene su simplicidad y y flexibilidad. Pasó de estar destinado a intercambio de archivos en un entorno de un laboratorio semi-seguro, a lo que es Internet actualmente.</p>
				</section>	

				<section>
				<h2>Comienzos de HTML</h2>
				
				<p>Se llamó, primeramente 'Mesh' y luego pasó a World Wide Web. Está desarollodo sobre los protocolos TCP e IP, basado en cuatro bloques:</p>
					<ol>
						<li>HyperText Transfer Protocol.</li>
						<li>HyperText Transfer Protocol</li>
						<li>Primer navegador Web: WorldWideWeb</li>
						<li>HTTPD</li>
					</ol>
				</section>

				<section>
					<h2>Comienzos de HTML</h2>
					<p>También se le conocía como HTTP/0.9. Una petición se hacía en una sóla línea, que comenzaba con un get, seguido del recurso a pedir.</p>
				</section>
				<section>
					<h2>Comienzos de HTML</h2>
					<p>No usaba cabeceras HTTP, es decir, sólo se podían transmitir archivos HTML y no de ningún otro tipo. También había información del estado ni códigos de error; si había un problema, el archivo HTML era devuelto con una descripción del problema.</p>					
				</section>
				</section>

				<section>
				<section>
					<h2>HTTP 1.0</h2>
					<p>Al ser la 0.9 poco flexible, actualizaron a este para serlo más:
					<ol>
						<li>La versión del protocolo se envía con cada petición.</li>
						<li>Se envía también un código de estado al comienzo de la respuesta.</li>
						<li>El concepto de cabeceras de HTTP, se presentó tanto para las peticiones como para las respuestas.</li>
						<li>Se pueden transmitir otros documentos además de HTML, mediante la cabecera Content-Type.</li>
					</ol>
				</section>

					<section>
					<h2>HTTP 1.0</h2>
					<p>Esto se llevó a cabo 1991 y 1995: un servidor y un navegador, añadían una nueva funcionalidad y se evaluaba su aceptación. Por esto, eran comunes los problemas de interoperatividad. En 1996, se publicó el RFC 1945, para acabar con los problemas, siendo este, la definición del protocolo HTTP/1.0.</p>
				
				</section>
				</section>
				<section>
						<h2>HTTP 1.1</h2>
					
					<section>
						<h3>Definicion</h3>
						<p>HTTP es un protocolo que nos permite obtener recursos, como documentos HTML. Es la fundacion de cualquier 
						intercambio de datos en la web y es un protocolo cliente-servidor, es decir que las solicitudes son iniciadas por
						el destinatario, normalmente el navegador web. Se reconstruye un documento completo a partir de los diferentes 
						sub-documentos obtenidos, por ejemplo texto, descripcion del diseño, imágenes etc.</p>
					</section>
					<section>

						
						<p>Los clientes y los servidores se comunican mediante el intercambio de mensajes individuales. A los mensajes enviados
						por el cliente (normalmente un navegador web) se les llama solicitudes mientras que los mensajes que
						envia el servidor son denominados respuestas.</p>
						
					</section>
					
					<section>
						<h3>Componentes de sistemas basados en HTTP</h3>
						<p>HTTP es un protocolo cleinte-servidor: las solicitudes son enviadas por una entidad, el agente de usuario (o proxy)
						La mayoria de las veces este es un navegador web. Cada solicitud individual se envia a un servidor que la maneja y nos
						manda una respuesta. Entre el cliente y el servidor hay varias entidades denominadas proxies, que realizas diferenes operaciones
						y actuan como puertas de enlace.</p>
						
					</section>
					
					
					<section>
						<h3>Aspectos básicos de HTTP</h3>
						<p>HTTP está generalmente disenado para ser simple y legible por humanos. Los mensajes HTTP pueden ser leidos y entendidos por
						humanos, proporcionando pruebas más faciles para desarrolladores.</p>
						
					</section>
					
					<section>
						<h3>HTTP es extensible</h3>
						<p>Los encabezados HTTP hacen que este protocolo sea facil de extender y experimentar. Incluso se puede introducir una nueva funcionalidad
						mediante un simple acuerdo entre un cliente y un servidor sobre la semantica de un nuevo encabezado.</p>
						
					</section>
					
					
				</section>


				
				<section>
					<section>
						<h2>HTTP2</h2>
					</section>
					<section>
						<h2>INTRODUCCIÓN</h2>
						<p>HTTP/2 (Protocolo de Transferencia de Hipertexto, versión 2) es un protocolo de red utilizado por la World Wide Web que llega con el objetivo de actualizar el protocolo HTTP/1.1, con el que es compatible.
						HTTP 2.0 no modifica la semántica de aplicación de Http. Todos los conceptos básicos, tales como los métodos HTTP,
						códigos de estado, URI, y campos de cabecera, se mantienen sin cambios; sin embargo, HTTP 2.0 introduce innumerables 
						mejoras como el uso de una única conexión, la compresión de cabeceras o el servicio ‘server push’.</p>
					</section>
					<section>
						<h2>MISMA SEMÁNTICA</h2>
						<p>El nuevo protocolo admite la misma semántica que HTTP / 1.1
						Esto permitirá que la mayoría de los beneficios de HTTP / 2 sean utilizados por las aplicaciones de 
						manera transparente simplemente actualizando la infraestructura del cliente y el servidor, pero sin ningún 
						cambio en el código de la aplicación.</p>
						<br>
					</section>
					
					<section>
						<h2>MULTIPLEXADO</h2>
						<p>HTTP / 2 es un protocolo multiplexado que permite que múltiples flujos de solicitud compartan 
						la misma conexión TCP / IP.</br>
						Mejoras del Multiplexado:</br>
							-Intercalar múltiples solicitudes en paralelo sin bloquear ninguna.</br>

							-Intercalar múltiples respuestas en paralelo sin bloquear a nadie.</br>

							-Use una sola conexión para entregar múltiples solicitudes y respuestas en paralelo.</br></p>
						<br>
					</section>
					
					
					<section>
						<p>-Ofrece tiempos de carga de página más bajos al eliminar la latencia innecesaria y mejorar la utilización de la capacidad de red disponible.</p>
						<br>
					</section>
					
					<section>
						<h2>COMPRESION</h2>
						<p>Los encabezados HTTP son muy detallados y altamente redundantes. HTTP / 2 proporciona un algoritmo de compresión 
						efectivo (HPACK) que se adapta a HTTP y evita muchos de los problemas de seguridad sobre conexiones TLS(Cliente servidor/Servidor-Servidor). El tamaño reducido del encabezado permite que se envíen muchas solicitudes a través de una conexión TCP / IP recién abierta sin la necesidad de esperar a que su ventana de control de congestión aumente a la capacidad del enlace. Esto reduce significativamente la cantidad de viajes de ida</p>
						<br>
					</section>
					
					<section>
						<p> y vuelta a la red necesarios para representar una página.</p>
					</section>
					
					
					<section>
						<h2>SERVER PUSH</h2>
						<p>Consiste en que el servidor será capaz de enviar información al cliente antes de que éste la solicite, es decir, el servidor intentará prever los recursos que el cliente va a necesitar y enviárselos antes a una caché especial para este propósito.El propósito de esto es mejorar las latencias y la cantidad de solucitudes que se envian.</p>
						<br>
					</section>
				</section>
				<section>
					<section>
						<h2>HTTP 3 QUIC</h2>
						<p>¿Qué es HTTP 3 QUIC?</p>
						<p>Es un protocolo de red experimental sobre la capa de transporte diseñado por Jim Roskind en Google, inicialmente implantado en 2012. 
							Este protocolo proporciona un entorno para la iteración rápida de algoritmos de prevención de congestión, estableciendo control en 
							el espacio de aplicación en ambos extremos, en lugar de hacerlo en el espacio kernel. </p>
						<br>
						
					</section>
					<section>
						
						<h3>¿Cual es su objetivo?</h3>
						<p>Su objetivo es desarrollar un protocolo que cumpla:</p> 
						<ul>
							<li>Un uso extendido del mismo en todo el mundo. </li>
							<li>Reducir la pérdida de paquetes por bloqueo head-of-line. </li>
							<li>Baja latencia.</li>
							<li>Mejorar el soporte para móviles, en términos de latencia y eficiencia.</li>
						</ul>
						
					</section>
					<section>
						
						<h3>Ventajas</h3>
						<p>QUIC resuelve el problema que tiene TCP utilizando un identificador único e independiente para cada 
						extremo de la conexión. Este ID de conexión tiene un tamaño de entre cuatro y dieciocho bytes, que es creado 
						de manera específica para la implementación de cada endpoint, lo que asegura que el endpoint pueda identificar 
						su propio ID en un paquete QUIC, ya que el ID de conexión de destino está presente en cada paquete.</p>
						
					</section>
					<section>
						<h3>Ventajas</h3>
						<p>Multiplexado: Permite enviar y recibir varios archivos al mismo tiempo, en este caso de manera más 
						eficiente que HTTP/2 al no tener el problema de bloqueo de la cabecera de la línea.</p>
						
						<p>Mejor control de la saturación: QUIC consiste en un control de saturación conectable y una señalización más 
						rica que TCP, lo que permite a QUIC proporcionar información más rica que TCP a los algoritmos de control de saturación. </p>
					</section>	
					
				</section>

			</div>

		</div>

		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
